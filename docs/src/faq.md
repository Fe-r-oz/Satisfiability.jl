# FAQ
```@contents
Pages = ["faq.md"]
Depth = 3
```

## Where can I get help?
Please open a Github issue! This is a new package and we would love to hear your suggestions, bug reports, feature requests, and other commentary.

## Isn't this functionality included in JuMP?
[JuMP](https://jump.dev/) provides support for [integer and Boolean-valued variables](https://jump.dev/JuMP.jl/stable/manual/variables/#Binary-variables), however it is developed primarily to support mathematical optimization over real-valued or integer-valued variables and continuous functions. As such, JuMP interfaces with solvers such as ECOS, MOSEK, and Gurobi that are intended for continuous optimization problems. When you use JuMP to solve a problem with discrete variables, your solver will likely use a branch-and-bound style method.

### Should I use JuMP or BooleanSatisfiability?
If you have a problem with mixed real and discrete variables, you should probably use JuMP to call a branch-and-bound solver.

If you have a problem with only discrete variables, especially a large one, you should consider using a SAT solver.

## How do I solve SAT problems in other langugages?
Z3 has [APIs](https://z3prover.github.io/api/html/index.html) for C, C++, .NET, Java, Python and ML/OCaml. Additionally, Microsoft Research provides [tutorials](https://microsoft.github.io/z3guide/programming/Z3%20JavaScript%20Examples) for using Z3 in Python and JavaScript.

## What about other theories in the SMT standard?
In the future support may be added for additional theories supported in the SMTLIB2 standard, such as bitvectors and arrays.

## How can I extract an unsatisfiability proof?
Instead of calling `sat!`, use `save` to write the SMT representation of your problem to a file. Then invoke the solver from your command line, feed it the file and issue `(get-proof)` in `unsat` mode.

Yes, that was a long way of saying "we don't support this feature". (Unsatisfiability proofs are difficult to support because the SMT2 standard doesn't specify their format - it's solver-dependent.) However you can still specify your problem in BooleanSatisfiability.jl and use the generated SMT file any way you like.

## What does BooleanSatisfiability.jl actually do?
We provide a high-level interface to SAT solvers. SAT solvers can accept input in the [SMT2](http://www.smtlib.org/) format, which is very powerful but not easy to read. When you specify a SAT problem in BooleanSatisfiability.jl and call `sat!`, we generate an SMT2-formatted **representation** of the problem, feed it to a solver, then interpret the result.

You can feed the solver yourself. Call `save` instead of SAT to write the SMT2 representation of your problem to a file, where you can inspect it or add additional commands.

# LFAQ
(Less frequently-asked questions.)

## Where do all the long, ugly names in the SMT file come from?
To prevent names from being duplicated, BooleanSatisfiability.jl names new expressions using the Julia `hash` of their child expressions.

For example, suppose you have
```@example
a = Int("a")
b = Int("b")
expr = a <= b
print(smt(expr))
```
The (long, ugly) name of the combined expression `a <= b` is generated by hashing the names `a` and `b`.

**Q:** Why don't you just concatenate `a` and `b` and call it `LEQ_a_b`?

**A:** Because what if we have `a = Int(10,"a"); expr = sum(a)`? Are we going to say `expr.name = ADD_a_1_a_2_a_3_a_4_a_5_a_6_a_7_a_8_a_9_a_10`? If not, where do we draw the line? What if we called it `ADD_a_1__a_10`, but then we defined `expr2 = a[1] + a[3:8] + a[10]`? Then both `expr` and `expr1` would share the name `ADD_a_1__a_10` and all heck would break loose.

If you think of a nicer way to name expressions, please open an issue!
 
